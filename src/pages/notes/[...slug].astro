---
import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import Header from '../../components/Header.astro';
import SearchModal from '../../components/SearchModal.astro';
import Backlinks from '../../components/Backlinks.astro';
import BacklinksScript from '../../components/BacklinksScript.astro';
import Footer from '../../components/Footer.astro';
import PlausibleScript from '../../components/PlausibleScript.astro';
import '../../styles/design-system.css';
import '../../styles/notes.css';

export async function getStaticPaths() {
	const notes = await getCollection('notes', ({ data }) => data.visibility === 'public');
	return notes.map((note) => ({
		params: { slug: note.slug },
		props: { entry: note },
	}));
}

interface Props {
	entry: CollectionEntry<'notes'>;
}

const { entry } = Astro.props;
const { Content } = await entry.render();
const { slug, data } = entry;
const title = data.title ?? slug;
---
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>{title} | Commune</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content={data.summary || title} />

    <!-- Open Graph -->
    <meta property="og:title" content={title} />
    <meta property="og:description" content={data.summary || title} />
    <meta property="og:type" content="article" />
    <meta property="og:url" content={Astro.url} />
    <meta property="og:site_name" content="Commune" />
    <meta property="og:image" content="https://devonmeadows.com/og-image.jpg" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    {data.created && <meta property="article:published_time" content={`${data.created}T00:00:00-07:00`} />}
    {data.updated && <meta property="article:modified_time" content={`${data.updated}T00:00:00-07:00`} />}

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={data.summary || title} />
    <meta name="twitter:image" content="https://devonmeadows.com/og-image.jpg" />

    <!-- Author -->
    <meta name="author" content={data.author || 'Devon Meadows'} />

    <link rel="icon" type="image/png" href="/favicon-32x32.png" />
    <PlausibleScript domain="devonmeadows.com" />

    <!-- JSON-LD Structured Data: Article + BreadcrumbList -->
    <script type="application/ld+json" set:html={JSON.stringify({
      "@context": "https://schema.org",
      "@graph": [
        {
          "@type": "Article",
          "headline": title,
          "description": data.summary || title,
          "author": {
            "@type": "Person",
            "name": data.author || 'Devon Meadows',
            "url": "https://devonmeadows.com/"
          },
          "datePublished": `${data.created || data.updated}T00:00:00-07:00`,
          "dateModified": `${data.updated}T00:00:00-07:00`,
          "url": Astro.url.href,
          "isPartOf": {
            "@id": "https://devonmeadows.com/#website"
          }
        },
        {
          "@type": "BreadcrumbList",
          "itemListElement": [
            {
              "@type": "ListItem",
              "position": 1,
              "name": "Home",
              "item": "https://devonmeadows.com/"
            },
            {
              "@type": "ListItem",
              "position": 2,
              "name": title,
              "item": Astro.url.href
            }
          ]
        }
      ]
    })} />
  </head>
  <body>
    <Header />
    <SearchModal />
    
    <main id="pane-container"> 
        
        <div class="pane" data-url="" tabindex="-1"> 
            <button class="close" aria-label="Close">×</button>
            <div class="body-wrapper">
                <div class="body">
                    <div class="pane-content">
                        <article class="prose">
                            <h1>{title}</h1>

                            {/* Metadata bar */}
                            <div class="note-meta">
                              {data.status && <span class={`status-badge status-${data.status}`}>{data.status}</span>}
                              {data.created && <span class="meta-date">Published {data.created}</span>}
                              {data.updated && data.updated !== data.created && (
                                <span class="meta-date">Updated {data.updated}</span>
                              )}
                            </div>

                            <Content />
                        </article>
                        <Backlinks slug={`/notes/${slug}/`} title={title} />
                        <Footer />
                    </div>
                </div>
            </div>
        </div>
        
    </main>

    <script is:inline>
      // === CLEAN WIKI ARCHITECTURE ===
      // Single initialization, event delegation, no duplicates

      if (window.wikiInitialized) {
        console.log('Wiki already initialized, skipping...');
      } else {
        console.log('Initializing wiki with clean architecture...');

        // --- Global State ---
        const previewCache = new Map();
        let isInitialized = false;

        // --- Utility Functions ---
        const normalizeUrl = (url) => new URL(url, window.location.origin).pathname;

        const showPreview = (el, html, x, y) => {
          try {
            let card = document.getElementById('note-hover');
            if(!card){
              card = document.createElement('div');
              card.id = 'note-hover';
              card.style.position = 'fixed';
              card.style.maxWidth = '420px';
              card.style.background = 'var(--c-bg)';
              card.style.boxShadow = 'var(--c-shadow-xl)';
              card.style.border = '1px solid var(--c-border)';
              card.style.borderRadius = 'var(--c-radius-lg)';
              card.style.padding = '1rem 1.2rem';
              card.style.zIndex = 'var(--z-hover)';
              card.style.pointerEvents = 'none';
              document.body.appendChild(card);
            }
            card.innerHTML = html;
            card.style.left = Math.min(x+16, window.innerWidth-460) + 'px';
            card.style.top = Math.min(y+16, window.innerHeight-220) + 'px';
            card.hidden = false;
          } catch (error) {
            console.error('Error showing hover card:', error);
          }
        };

        const hidePreview = () => {
          try {
            const card = document.getElementById('note-hover');
            if (card) card.hidden = true;
          } catch (error) {
            console.error('Error hiding hover card:', error);
          }
        };


        // --- Preview Event Handler ---
        const handlePreviewHover = async (e) => {
          try {
            const a = e.target?.closest?.('a[href^="/notes/"]');
            if(!a) return;
            const url = a.getAttribute('href');
            if(previewCache.has(url)){
              showPreview(a, previewCache.get(url), e.clientX, e.clientY);
              return;
            }

            // Show immediate loading state
            showPreview(a, '<div style="font-weight:600;color:var(--c-text-muted)">Loading preview...</div>', e.clientX, e.clientY);

            // Reduced timeout for faster response
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000);

            const r = await fetch(url, {
              signal: controller.signal,
              headers: { 'Accept': 'text/html' }
            });
            clearTimeout(timeoutId);

            if (!r.ok) {
              showPreview(a, '<div style="color:var(--c-text-muted)">Preview unavailable</div>', e.clientX, e.clientY);
              return;
            }

            const t = await r.text();
            const doc = new DOMParser().parseFromString(t, 'text/html');
            const content = doc.querySelector('.pane .pane-content') ?? doc.body;
            const paras = Array.from(content.querySelectorAll('p')).slice(0,3).map(p => p.outerHTML).join('');
            const title = doc.title?.replace(/ \|.*/, '') || 'Untitled';
            const html = `<div style="font-weight:600;margin-bottom:.3rem">${title}</div>${paras}`;
            previewCache.set(url, html);
            showPreview(a, html, e.clientX, e.clientY);
          } catch (error) {
            if (error.name !== 'AbortError') {
              showPreview(a, '<div style="color:var(--c-text-muted)">Preview failed</div>', e.clientX, e.clientY);
            }
          }
        };

        const handlePreviewLeave = (e) => {
          try {
            const a = e.target?.closest?.('a[href^="/notes/"]');
            if(a) setTimeout(hidePreview, 100);
          } catch (error) {
            console.error('Error in mouseleave handler:', error);
          }
        };

        // --- Pane Management Functions ---
        const container = document.getElementById('pane-container');
        if (!container) {
          console.error('Pane container not found!');
        } else {

        const updateContainerLayout = () => {
          const paneCount = container.querySelectorAll('.pane').length;
          container.classList.toggle('multi-pane', paneCount > 1);
        };

        const openPane = async (url) => {
          try {
            console.log(`Opening pane for: ${url}`);
            const normalizedUrl = normalizeUrl(url);

            // Check for existing pane to prevent duplicates
            const existingPane = container.querySelector(`[data-url="${normalizedUrl}"]`);
            if (existingPane) {
              console.log('Pane already exists, focusing existing pane');
              focusPane(existingPane);
              return;
            }

            // Fetch content
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);

            const res = await fetch(url, {
              headers: { 'Accept': 'text/html;charset=utf-8' },
              signal: controller.signal
            });
            clearTimeout(timeoutId);

            if (!res.ok) {
              console.error(`Failed to fetch pane content: ${res.status}`);
              return;
            }

            const html = await res.text();
            const doc = new DOMParser().parseFromString(html, 'text/html');
            const fetchedContent = doc.querySelector('.pane .pane-content');

            if (!fetchedContent) {
              console.error('No .pane-content found in fetched page');
              return;
            }

            // Create new pane
            const pane = document.createElement('div');
            pane.className = 'pane';
            pane.dataset.url = normalizedUrl;
            pane.setAttribute('tabindex', '-1');

            pane.innerHTML = `
                <button class="close" aria-label="Close">×</button>
                <div class="body-wrapper">
                    <div class="body">
                        <div class="pane-content">${fetchedContent.innerHTML}</div>
                    </div>
                </div>
            `;

            // Attach close listener
            pane.querySelector('.close').addEventListener('click', (e) => {
                e.stopPropagation();
                closePane(pane);
            });

            // Append and focus
            container.appendChild(pane);
            void pane.offsetHeight;
            updateContainerLayout();

            // Initialize backlinks for the new pane
            if (typeof window.initializeBacklinks === 'function') {
              window.initializeBacklinks(pane);
            }

            setTimeout(() => focusPane(pane), 0);
            console.log('Pane opened successfully');
          } catch (error) {
            console.error('Error opening pane:', error);
            if (error.name !== 'AbortError') {
              window.location.href = url;
            }
          }
        };

        const focusPane = (pane) => {
          requestAnimationFrame(() => {
            if (document.activeElement && document.activeElement !== pane && document.activeElement.blur) {
              document.activeElement.blur();
            }
            pane.focus({ preventScroll: true });
            // Only scroll pane into view on desktop (>= 1024px)
            // On mobile, panes fill the viewport so scrollIntoView is not needed
            if (window.innerWidth >= 1024) {
              requestAnimationFrame(() => {
                pane.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
              });
            }
          });
        };

        const closePane = (pane) => {
          if (pane === container.firstElementChild) return;
          const previousPane = pane.previousElementSibling;
          pane.remove();
          updateContainerLayout();
          if (previousPane && previousPane.classList.contains('pane')) {
            focusPane(previousPane);
            if (previousPane.dataset.url) {
              history.replaceState({ pane: previousPane.dataset.url }, '', previousPane.dataset.url);
            }
          }
        };

        // --- Single Event Delegation Handler ---
        const handleWikiClick = (e) => {
          // Handle link clicks within content
          const inContent = e.target?.closest?.('article.prose, aside.backlinks');
          if (inContent) {
            const a = e.target?.closest?.('a[href^="/notes/"]');
            if (a) {
              // Don't intercept if modifier keys are pressed
              if (e.ctrlKey || e.metaKey || e.shiftKey) return;

              // On desktop (>= 1024px), intercept. On mobile, allow normal navigation.
              if (window.innerWidth < 1024) return;

              // Intercept the link and open in a pane!
              e.preventDefault();
              const targetUrl = normalizeUrl(a.href);

              openPane(a.href);
              history.pushState({ pane: targetUrl }, '', targetUrl);
              return;
            }
          }

          // Handle pane focusing (only if we didn't handle a content link)
          if (e.target?.closest('a, button, input, textarea')) {
            return;
          }

          const clickedPane = e.target?.closest?.('.pane');
          if (clickedPane && document.activeElement !== clickedPane) {
            focusPane(clickedPane);
            if (clickedPane.dataset.url) {
              history.pushState({ pane: clickedPane.dataset.url }, '', clickedPane.dataset.url);
            }
          }
        };

        // Handle popstate (browser history navigation)
        const handlePopstate = () => {
          const targetUrl = normalizeUrl(window.location.href);
          const panes = Array.from(container.querySelectorAll('.pane'));
          const targetIndex = panes.findLastIndex(p => p.dataset.url === targetUrl);

          if (targetIndex !== -1) {
            for (let i = panes.length - 1; i > targetIndex; i--) {
              panes[i].remove();
            }
            updateContainerLayout();
            focusPane(panes[targetIndex]);
          } else {
            window.location.reload();
          }
        };

        // Initialize the first pane
        const firstPane = container.querySelector('.pane');
        if (firstPane) {
          firstPane.dataset.url = normalizeUrl(window.location.href);
          focusPane(firstPane);
          updateContainerLayout();
        }

        // --- SINGLE EVENT DELEGATION SETUP ---
        // Remove any existing listeners to prevent duplicates
        document.removeEventListener('mouseenter', handlePreviewHover, true);
        document.removeEventListener('mouseleave', handlePreviewLeave, true);
        container.removeEventListener('click', handleWikiClick);
        window.removeEventListener('popstate', handlePopstate);

        // Add hover preview listeners ONLY on desktop (>= 1024px)
        // This prevents the brief preview flash on mobile/tablet when tapping links
        if (window.innerWidth >= 1024) {
          document.addEventListener('mouseenter', handlePreviewHover, true);
          document.addEventListener('mouseleave', handlePreviewLeave, true);
        }

        // Add navigation listeners on all devices
        container.addEventListener('click', handleWikiClick);
        window.addEventListener('popstate', handlePopstate);

        // Mark as successfully initialized
        window.wikiInitialized = true;
        console.log('Wiki initialized with clean architecture');
        } // Close the else block for container check
      }


    </script>
    <BacklinksScript />
  </body>
</html>

<style is:global>
  /* Ensure body scroll is locked on desktop as the pane container handles it */
  @media (min-width: 1024px) {
    body {
      overflow: hidden;
    }
  }

  /* Define variables and responsive adjustments */
  :root {
      --header-height: 64px;
      --transition-timing: 0.35s cubic-bezier(0.22, 1, 0.36, 1);
      --container-padding-h: 3vw; /* Horizontal padding when left-aligned */

      /* Default (Large Desktop > 1600px): Optimized for readability, aims for ~3 panes */
      --pane-width: clamp(500px, 40vw, 700px);
      --collapsed-visible-width: 120px;
  }

  /* Medium Desktop (e.g., 1440px laptop) - Adjust for better multi-pane view, aims for ~2-3 panes */
  @media (max-width: 1600px) {
      :root {
          --pane-width: clamp(480px, 45vw, 680px);
          --collapsed-visible-width: 100px;
      }
  }

  /* Small Desktop (e.g., 1280px) - Aims for ~2 panes */
   @media (max-width: 1280px) {
      :root {
          --pane-width: clamp(450px, 50vw, 650px);
          --collapsed-visible-width: 80px;
      }
  }

  /* --- Pane Container --- */
  #pane-container {
    display: flex;
    flex-direction: row;
    align-items: flex-start; 
    overflow-x: auto; 
    /* Position absolutely to cover the viewport below the header */
    position: absolute;
    top: var(--header-height);
    bottom: 0;
    left: 0;
    right: 0;
    padding: 1.5rem 0; /* Vertical padding for the container */
    scroll-behavior: smooth;

    /* FIX: Ensure pane area sits above page content but below header */
    z-index: var(--z-panes);

    /* Default (Single Pane): Center the pane */
    /* Calculates required padding to center the pane, ensuring a minimum standard padding */
    padding-left: max(var(--container-padding-h), calc(50vw - var(--pane-width) / 2));
    
    /* Add transition for the alignment shift */
    transition: padding-left var(--transition-timing);
  }

  /* When multiple panes are open (via JS class), shift alignment to the left */
  #pane-container.multi-pane {
    padding-left: var(--container-padding-h);
  }


  /* Hide the horizontal scrollbar on the main container */
  #pane-container::-webkit-scrollbar {
      display: none;
  }
  #pane-container {
      -ms-overflow-style: none;  /* IE and Edge */
      scrollbar-width: none;  /* Firefox */
  }


  /* --- Individual Pane Styling & Cascading Logic --- */
  .pane {
    /* FIX: flex-basis is more reliable than width for flex children */
    flex: 0 0 var(--pane-width);
    width: var(--pane-width);
    min-width: 0;
    max-width: var(--pane-width);
    
    background: var(--c-bg);
    
    /* Height management */
    height: calc(100vh - var(--header-height) - 3rem); 

    /* Clip content that overflows the pane boundary horizontally */
    overflow: hidden; 

    /* FIX: Set position relative so the absolute close button anchors to it */
    position: relative;
    outline: none; /* Remove default focus outline */
    
    /* FIX: Z-index layering ensures active pane always paints on top with negative margin stack */
    z-index: 1; /* Baseline for all panes */
    
    /* Cascading effect: Negative margin pulls the next pane closer */
    margin-right: calc(var(--pane-width) * -1 + var(--collapsed-visible-width));

    /* Smooth transition for the sliding/collapsing effect */
    transition: margin-right var(--transition-timing), 
                box-shadow 0.3s ease, 
                border-color 0.3s ease;
    
    /* Default styles for subsequent panes (cards) */
    border-radius: var(--c-radius-md);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); /* Softer shadow when collapsed */
    border: 1px solid var(--c-border);
  }

  /* FIX: Bump z-index on hover and focus to ensure proper paint order */
  .pane:hover {
    z-index: 2;
  }
  
  .pane:focus-within {
    z-index: 3;
  }

  /* Differentiate the first pane: Make it look like the main page content (no card styles) */
  .pane:first-child {
      box-shadow: none;
      border: none;
      border-radius: 0;
  }

  /* When a pane is focused (clicked or scrolled to), expand it */
  .pane:focus-within {
      /* Expand the focused pane to have normal spacing */
      margin-right: 1.5rem; 
      border-color: var(--c-accent-border);
      /* Stronger shadow when focused (for depth) */
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.1);
  }

  /* Ensure the first pane doesn't get card styles even when focused */
   .pane:first-child:focus-within {
      box-shadow: none;
      border: none;
   }

  /* The last pane should always have spacing on the right edge of the screen */
  /* Default (Single Pane): Needs centering margin on the right */
  .pane:last-child {
      margin-right: max(var(--container-padding-h), calc(50vw - var(--pane-width) / 2));
      transition: margin-right var(--transition-timing); /* Animate the margin shift */
  }

  /* When multiple panes are open, the last pane only needs standard spacing */
  #pane-container.multi-pane .pane:last-child {
     margin-right: var(--container-padding-h);
  }

  
  /* --- Pane Content Wrapper (Handles internal scrolling) --- */
  .pane .body-wrapper {
      height: 100%;
      overflow-y: auto;
      overflow-x: hidden;
      /* Optional: Style the vertical scrollbar inside the pane */
      scrollbar-width: thin;
      scrollbar-color: var(--c-border) transparent;
  }

  /* --- Pane Content --- */
  .pane .body {
    /* FIX: Adjusted padding. Increased right padding slightly to ensure text doesn't run under the absolute button. */
    padding: 2rem 2.5rem 4rem 1.5rem;
    max-width: 65ch;
    margin: 0 auto;
  }

  /* --- Close Button --- */
  /* Hide close button on the first pane */
  .pane:first-child .close {
    display: none;
  }

  .pane .close { 
    /* FIX: Revert to absolute positioning, anchored to the .pane */
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 10; /* Ensure it's above content */

    /* Reset float styles that caused the issue */
    float: none;
    margin: 0;

    width: 32px;
    height: 32px;
    background: var(--c-bg-soft);
    border: 1px solid var(--c-border);
    border-radius: 50%; /* Circular button */
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 1.3rem; 
    line-height: 1;
    color: var(--c-text-muted);
    transition: all 0.15s ease;
    opacity: 0.8;
    flex-shrink: 0;
  }
  
  .pane .close:hover { 
    background: var(--c-bg-muted); 
    color: var(--c-text);
    opacity: 1;
  }

  /* --- Typography (Existing styles, optimized) --- */
  /* Keep your existing .prose styles here */
  .prose{font-size:1.05rem;line-height:1.7;color:var(--c-text)}
  .prose a{
    color:var(--c-accent) !important;
    text-decoration:none;
    border-bottom:2px solid var(--c-accent);
    padding-bottom:1px;
    transition:all 0.15s ease;
  }
  .prose a:hover{
    color:var(--c-accent-hover) !important;
    background:var(--c-accent-soft);
    border-bottom-color:var(--c-accent-hover);
  }
  .prose h1{font-size:2.4rem;line-height:1.2;margin:.2rem 0 1.5rem;font-weight:700}
  .prose h2{font-size:1.75rem;margin-top:2.5rem;margin-bottom:1rem;font-weight:600}
  .prose h3{font-size:1.35rem;margin-top:2rem;margin-bottom:0.75rem;font-weight:600}
  .prose p{margin:1.25rem 0;line-height:1.75}

  /* Note metadata bar (status badge + dates) */
  .note-meta {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
    font-size: 0.9rem;
    color: var(--c-text-muted);
  }

  .status-badge {
    padding: 0.25rem 0.75rem;
    border-radius: 9999px;
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .status-draft {
    background: var(--c-bg-soft);
    color: var(--c-text-muted);
  }

  .status-live {
    background: rgba(34, 197, 94, 0.1);
    color: rgb(22, 163, 74);
  }

  .status-updated {
    background: rgba(59, 130, 246, 0.1);
    color: rgb(37, 99, 235);
  }

  .meta-date {
    font-variant-numeric: tabular-nums;
  }

  /* Mobile: Reduce title size to match Substack (~30px instead of ~38px) */
  @media (max-width: 1023px) {
    .prose h1 {
      font-size: 1.875rem; /* ~30px */
      line-height: 1.25;
    }
  }
  
  .prose ul,.prose ol{margin:1.25rem 0;padding-left:1.75rem}
  .prose li{margin:0.5rem 0}
  .prose code{
    background:var(--c-bg-soft);
    padding:0.2rem 0.4rem;
    border-radius:var(--c-radius-sm);
    font-size:0.9em;
  }
  .prose blockquote{
    border-left:3px solid var(--c-border);
    padding-left:1rem;
    margin:1.5rem 0;
    color:var(--c-text-muted);
    font-style:italic;
  }


  /* --- Fallback mode when JavaScript fails --- */
  body.wiki-fallback-mode #pane-container {
    padding-left: 0 !important;
    flex-direction: column;
    position: relative;
    top: 0;
    overflow-x: hidden;
  }
  
  body.wiki-fallback-mode .pane {
    width: 100%;
    margin-right: 0 !important;
    height: auto;
    min-height: auto;
    box-shadow: none !important;
    border: none !important;
    border-radius: 0 !important;
  }
  
  body.wiki-fallback-mode .pane .body-wrapper {
    height: auto;
    overflow-y: visible;
  }

  /* --- Mobile/Tablet Breakpoint (<= 1023px) --- */
  @media (max-width: 1023px) {
    /* Switch to optimized single column layout on mobile */
    #pane-container {
      position: static;
      padding: 0;
      flex-direction: column;
      align-items: stretch;
      overflow-x: hidden;
    }
    .pane {
      width: 100vw;
      --pane-width: 100vw;
      margin-right: 0 !important;
      height: auto;
      overflow: visible;
      box-shadow: none !important;
      border: none !important;
      border-radius: 0 !important;
    }
    /* Ensure the wrapper doesn't constrain height on mobile */
    .pane .body-wrapper {
        height: auto;
        overflow: visible;
    }
    .pane .body {
        padding: 2rem 1.5rem;
    }
    /* Hide dynamically loaded panes on mobile. */
    .pane:not(:first-child) {
      display: none;
    }
  }
</style>
